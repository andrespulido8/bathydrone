# LAST UPDATE: Nicholas Sardinia, Febuary 20 2023
"""
Updated algorithm to generate waypoints for convex polygons (semi-functional)
"""

#!/usr/bin/env python3
import matplotlib.pyplot as plt
import numpy as np

# Define the boat hardware
class HardwareSpecs:
    # accounts for radius of curvature and side-scan sonar geometry
    def __init__(self, D, alpha_2):
        self.rho = D*np.tan(alpha_2)
        # rho - radius that constrains the spacing between each
        # D - estimated depth of water
        # alpha_2 = Measured angle related to coverage of side-scan sonar

"""
Generates path, starting from lower-left corner. 
# Lawnmower lines for full convex coveragae.
# Returns path as a series of grid points from bottom left to top right
"""
class pathPlanner:
    def __init__(self, pointsX, pointsY, rho):
        self.pointsX = pointsX
        self.pointsY = pointsY
        self.rho = rho
        self.pathX = []
        self.pathY = []


        pathDirection = 0
        UP = 1
        DOWN = -1

        #find point at min X
        minXDex = 0
        minX = pointsX[0]
        for i in range(0, len(pointsX)):
            if pointsX[i] < minX:
                minX = pointsX[i]
                minXDex = i

        #generate starting point of path
        self.pathX.append(pointsX[minXDex]+3*rho)
        self.pathY.append(pointsY[minXDex])
        

        #determine starting movement direction
        #find closest surrounding points on top / bottom in X.
        xLeftBot = 0
        xRightBot = 0
        xLeftTop = 0
        xRightTop = 0
        for i in range(0, len(pointsX)):
            if pointsY[i] >= self.pathY[0] and pointsX[i] <= self.pathX[0]:
                xLeftTop = i
            if pointsY[i] <= self.pathY[0] and pointsX[i] <= self.pathX[0]:
                xLeftBot = i
            if pointsY[i] >= self.pathY[0] and pointsX[i] >= self.pathX[0]:
                xRightTop = i
            if pointsY[i] <= self.pathY[0] and pointsX[i] >= self.pathX[0]:
                xRightBot = i
        
        """
        print(pointsY[xRightBot])
        print(pointsY[xLeftBot])
        print(pointsX[xLeftBot])
        print(pointsX[xRightBot])

        print(pointsY[xRightTop])
        print(pointsY[xLeftTop])
        print(pointsX[xLeftTop])
        print(pointsX[xRightTop])
        print(self.pathY[0])
        """
        interpBot = self.pathY[0] - (pointsY[xRightBot]-pointsY[xLeftBot])/(pointsX[xLeftBot]-pointsX[xRightBot])*(rho)
        interpTop = self.pathY[0] + (pointsY[xRightTop]-pointsY[xLeftTop])/(abs(pointsX[xLeftTop]-pointsX[xRightTop]))*(rho)

        """
        print(interpBot)
        print(interpTop)
        """
        #Find starting direction of motion
        if (self.pathY[0] - interpBot >= interpTop-self.pathY[0]):
            direction = -1
        else:
            direction = 1

        #account for initial direction in setup
        if direction == DOWN:
            self.pathY[0] = self.pathY[0] - rho

        #print(direction)

        """
        #Starting direction and position found, now for the wayfinding algorithm.
        #depending on direction, find either top or bottom. Then, place a point at y: top(curr)-2rho or bottom(curr)+2rho. 
        #Then, place a second point x: curr + rho and y: top(curr+rho)-2rho or bottom(curr+rho)+rho
        """

        #find max point in x(stopping criterion)
        maxX = pointsX[0]
        for i in range(0, len(pointsX)):
            if pointsX[i] > maxX:
                maxX = pointsX[i]

        currDex = 0
        currX = self.pathX[0]
        currY = self.pathY[0]
        
        while True:
            if self.pathX[currDex] >= maxX:
                break
            if direction == UP:
                #find upper points and interpolate.
                if (currDex < 2):
                    for i in range(0, len(pointsX)):
                        if pointsY[i] >= currY and pointsX[i] <= currX:
                            xLeftTop = i
                        if pointsY[i] >= currY and pointsX[i] >= currX:
                            xRightTop = i
                else:
                    for i in range(0, len(pointsX)):
                        if pointsY[i] >= self.pathY[currDex-2] and pointsX[i] <= currX:
                            xLeftTop = i
                        if pointsY[i] >= self.pathY[currDex-2] and pointsX[i] >= currX:
                            xRightTop = i
                slope = (pointsY[xRightTop]-pointsY[xLeftTop])/(pointsX[xRightTop]-pointsX[xLeftTop])
                interpTop = pointsY[xLeftTop] + slope*(currX-(pointsX[xLeftTop]))
                #add point
                self.pathX.append(currX)
                self.pathY.append(interpTop)
                #print(self.pathY)

                #move over by rho
                currY = pointsY[xLeftTop] + slope*(currX-(pointsX[xLeftTop]))
                self.pathX.append(currX+rho)
                self.pathY.append(currY)
                #find upper points and interpolate
                currX = currX + rho
                #Update indices
                currDex = currDex + 2
                
               # print("top")
               # print(xLeftTop)
               # print(xRightTop)
                direction = direction * (-1)
            else:
                if (currDex < 2):
                    for i in range(0, len(pointsX)):
                        if pointsY[i] >= self.pathY[currDex] and pointsX[i] <= self.pathX[currDex]:
                            xLeftTop = i
                        if pointsY[i] <= self.pathY[currDex] and pointsX[i] <= self.pathX[currDex]:
                            xLeftBot = i
                        if pointsY[i] >= self.pathY[currDex] and pointsX[i] >= self.pathX[currDex]:
                            xRightTop = i
                        if pointsY[i] <= self.pathY[currDex] and pointsX[i] >= self.pathX[currDex]:
                            xRightBot = i
                else:
                    for i in range(0, len(pointsX)):
                        if pointsY[i] >= self.pathY[currDex-2] and pointsX[i] <= self.pathX[currDex]:
                            xLeftTop = i
                        if pointsY[i] <= self.pathY[currDex-2] and pointsX[i] <= self.pathX[currDex]:
                            xLeftBot = i
                        if pointsY[i] >= self.pathY[currDex-2] and pointsX[i] >= self.pathX[currDex]:
                            xRightTop = i
                        if pointsY[i] <= self.pathY[currDex-2] and pointsX[i] >= self.pathX[currDex]:
                            xRightBot = i
                slope = (pointsY[xRightBot]-pointsY[xLeftBot])/(pointsX[xLeftBot]-pointsX[xRightBot])
                interpBot = pointsY[xLeftBot] - (pointsY[xRightBot]-pointsY[xLeftBot])/(pointsX[xLeftBot]-pointsX[xRightBot])*(currX-(pointsX[xLeftBot]))

                #add point
                #print(interpBot)
                self.pathX.append(currX)
                self.pathY.append(interpBot)

                #move over by rho
                currX = currX + rho
                currY = interpBot
                currY = currY - slope*(rho)
                self.pathX.append(currX)
                self.pathY.append(currY)

                #Update indices
                currDex = currDex + 2
               # print("bot")
               # print(xLeftBot)
               # print(pointsY[xLeftBot])
               # print(xRightBot)
               # print(pointsY[xRightBot])
                direction = direction * (-1)


#path_planner improvements
class pathPlannerMarch:
    def __init__(self, pointsX, pointsY, rho):
        self.pointsX = pointsX
        self.pointsY = pointsY
        self.rho = rho
        self.pathX = []
        self.pathY = []

        pathDirection = 0
        UP = 1
        DOWN = -1

        minXDex = 0
        minX = pointsX[0]
        for i in range(0, len(pointsX)):
            if pointsX[i] < minX:
                minX = pointsX[i]
                minXDex = i

        self.pathX.append(pointsX[minXDex])
        self.pathY.append(pointsY[minXDex])

        #First "Iteration Righward" = pointsX[minXDex] + rho
        firstIter = pointsX[minXDex] + rho

        xLeftBot = 0
        xRightBot = 0
        xLeftTop = 0
        xRightTop = 0

        #Vertical line
        if (pointsX[0] == pointsX[1]):
            #there is a vertical line
            interpTop = pointsY[1]
        else:
            for i in range(0, len(pointsX)):
                if pointsY[i] >= self.pathY[0] and pointsX[i] <= firstIter:
                    xLeftTop = i
                if pointsY[i] >= self.pathY[0] and pointsX[i] >= firstIter:
                    xRightTop = i
            interpTop = self.pathY[0] + (pointsY[xRightTop]-pointsY[xLeftTop])/(abs(pointsX[xLeftTop]-pointsX[xRightTop]))*(rho)
        #X-2, because in a closed polygon, the first point will always equal the last point
        if (pointsX[0] == pointsX[len(pointsX)-2]):
            #there is a vertical line below our point
            interpBot = pointsY[len(pointsX)-2]
        else:
            for i in range(0, len(pointsX)):
                if pointsY[i] <= self.pathY[0] and pointsX[i] <= firstIter:
                    xLeftBot = i
                if pointsY[i] <= self.pathY[0] and pointsX[i] >= firstIter:
                        xRightBot = i
                interpBot = self.pathY[0] - (pointsY[xRightBot]-pointsY[xLeftBot])/(pointsX[xLeftBot]-pointsX[xRightBot])*(rho)
        
        #Choose path direction and place first waypoint
        if (self.pathY[0] - interpBot >= interpTop-self.pathY[0]):
            pathDirection = -1
            self.pathX.append(firstIter)
            self.pathY.append(interpBot)
        else:
            pathDirection = 1
            self.pathX.append(firstIter)
            self.pathY.append(interpTop)

        #Sweep the shape

        #find max point in x(stopping criterion)
        maxX = pointsX[0]
        for i in range(0, len(pointsX)):
            if pointsX[i] > maxX:
                maxX = pointsX[i]

        currDex = 0
        currX = self.pathX[0]
        currY = self.pathY[0]

        #Generates Waypoints
        while True:
            currDex = currDex + 1
            if maxX < pointsX[currDex] + rho:
                break
            
                
#Simple optimal sweep direction is parallel to the minimum width direction of the convex polygon
#This minimizes the number of turns taken by the path
def findBestSweepDirection(xPoints, yPoints): 
    #find optimal matrix direction 
    xRot = []
    yRot = []
    tempPoints = []    
    opAngleDist = max(xPoints)-min(xPoints)
    opAngle = 0
    for testAngle in range(1, 360):
        #print(opAngle)
        transformAngle = [[np.cos(np.deg2rad(testAngle)), -np.sin(np.deg2rad(testAngle))], [np.sin(np.deg2rad(testAngle)), np.cos(np.deg2rad(testAngle))]]
        tempX = [] 
        for p in range(0, len(xPoints)):
            xyMat = [[xPoints[p]], [yPoints[p]]]
            tempPoints.append(np.matmul(transformAngle, xyMat))
        for p in range(0, len(xPoints)):
            tempX.append(tempPoints[p][0])
        if max(tempX)-min(tempX) < opAngleDist:
            opAngleDist = max(tempX) - min(tempX)
            opAngle = testAngle
        tempPoints = []
    #print(opAngle) 

    #Now rotate the shape by the angle
    finalTransform = [[np.cos(np.deg2rad(opAngle)), -np.sin(np.deg2rad(opAngle))], [np.sin(np.deg2rad(opAngle)), np.cos(np.deg2rad(opAngle))]]
    tempPointsFinal = []
    for i in range(0, len(xPoints)):
         xyMatNew = [[xPoints[i]], [yPoints[i]]]
         tempPointsFinal.append(np.matmul(finalTransform, xyMatNew))
    for p in range(0, len(xPoints)):
            xRot.append(tempPointsFinal[p][0])
            yRot.append(tempPointsFinal[p][1])
    #print(xRot) 
    #print(yRot)
    
    return xRot, yRot
    
def plotGrid(xPoints, yPoints):
    plt.title("Bathydrone Boat Path")
    plt.xlabel("X")
    plt.ylabel("Y")

    plt.grid()
    plt.plot(xPoints, yPoints, marker='o', color='red')
    plt.axis('square')
    plt.show()

def plotPath(xPoints, yPoints, bathyPath):
    plt.title("Bathydrone Boat Path")
    plt.xlabel("X")
    plt.ylabel("Y")

    plt.grid()
    myPlot = plt.plot(xPoints, yPoints, marker='o', color='red')
    plt.plot(bathyPath.pathX, bathyPath.pathY, marker='o', color='green', markersize='2')
    plt.axis('square')
    plt.show()

def main():
    #input closed area as points. 

    #Atshushi's Polygon
    xPoints = [0.0, 20.0, 50.0, 100.0, 130.0, 40.0, 0.0]
    yPoints = [0.0, -20.0, -10, 30.0, 60.0, 80.0, 0.0]

    #Square
    xPointsSq = [0.0, 0.0, 100.0, 100.0, 0.0]
    yPointsSq = [0.0, 100.0, 100.0, 0.0, 0.0]

    #Irregular Octagon
    xPointsOct = [0.0, 0.0, 40.0, 80.0, 120.0, 120.0, 75.0, 30.0, 0.0]
    yPointsOct = [0.0, 60.0, 100.0,  100.0, 70.0, -10.0, -50.0, -50.0, 0.0]

    
    xRot, yRot = findBestSweepDirection(xPointsOct, yPointsOct)

    plotGrid(xPointsOct, yPointsOct) 
    #testGrid = plotGrid(xRot, yRot)
    boatSpecs = HardwareSpecs(1.25, 1.25) 
    bathyPath = pathPlannerMarch(xRot, yRot, boatSpecs.rho)
    plotPath(xRot, yRot, bathyPath)
    return 0


if __name__ == "__main__":
    main()


