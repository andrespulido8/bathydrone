# LAST UPDATE: Nicholas Sardinia, Febuary 19 2023
"""
Updated algorithm to rotate polygons to semi-optimal orientation (by minimum number of turns)
"""

#!/usr/bin/env python3
import matplotlib.pyplot as plt
import numpy as np

# Define the boat hardware
class HardwareSpecs:
    # accounts for radius of curvature and side-scan sonar geometry
    def __init__(self, D, alpha_2):
        self.rho = D*np.tan(alpha_2)
        # rho - radius that constrains the spacing between each
        # D - estimated depth of water
        # alpha_2 = Measured angle related to coverage of side-scan sonar

"""
Generates path, starting from lower-left corner. 
# Lawnmower lines for full convex coveragae.
# Returns path as a series of grid points from bottom left to top right
"""
class Path:
    def __init__(self, pointsX, pointsY, rho):
        self.pointsX = pointsX
        self.pointsY = pointsY
        self.rho = rho
        self.pathX = []
        self.pathY = []
        
        # generate starting point
        self.pathX.append(pointsX[0]+rho)
        self.pathY.append(pointsY[0]+rho)

        # generate path
            # find highest y at current x
            # add point at highest y - rho
            # move right by rho
            # find lowest y at current x
            # move right by rho
            # repeat until currentx = max_x

        done = 0
        currX = self.pointsX[0]+rho
        currY = self.pathY[0]
        
        maxX = 0
        countCurr = 1
        closestLeftSave = 0
        closestRightSave = maxX
        for i in range(len(self.pointsX)):
            if (self.pointsX[i] >= self.pointsX[maxX]):
                maxX = i
        print(self.pointsX[maxX])
        while done != 1:
            print("next")
            if (currX >= self.pointsX[maxX]-rho):
                done = 1
                break
            closestRight = maxX
            closestLeft = 0
            #find the x-points that most nearly bound the current x above the current x position
            for i in range(len(self.pointsX)-1):
                if (self.pointsX[i] >= self.pointsX[closestLeft] and self.pointsX[i]  < currX):
                    closestLeft = i
                if (self.pointsX[i] < self.pointsX[closestRight] and self.pointsX[i]  > currX):
                    closestRight = i
                    #print(self.pointsX[closestRight])
            print(closestLeft)
            print(closestRight)
            #From the tightest bound on X, we may find the next vertical point by interpolation.
            if (closestLeftSave != closestLeft or closestRightSave != closestRight):
                closestLeftSave = closestLeft
                closestRightSave = closestRight
                if (countCurr > 3):
                    countCurr = 1
            if ((self.pointsX[closestRight] - self.pointsX[closestLeft]) != 0):
                slope = (self.pointsY[closestRight]-self.pointsY[closestLeft])/(self.pointsX[closestRight] - self.pointsX[closestLeft])
                print(self.pointsY[closestRight]-self.pointsY[closestLeft])
                print(self.pointsX[closestRight] - self.pointsX[closestLeft])
                print(slope)
            else:
                slope = 0
            vertPos = self.pointsY[closestLeft] + slope*rho*countCurr - 6*rho
            currY = vertPos

            #add point at vertpos
            self.pathX.append(currX)
            self.pathY.append(vertPos)

            #add point to the right of vertpos
            self.pathX.append(currX+rho)
            self.pathY.append(vertPos)

            #TODO allow paths below starting x
            currX = currX + rho
            self.pathX.append(currX)
            self.pathY.append(pointsY[0]+rho)

            currX = currX + rho
            #print(currX)
            self.pathX.append(currX)
            self.pathY.append(pointsY[0]+rho)
            countCurr = countCurr + 2
             
            
#Simple optimal sweep direction is parallel to the minimum width direction of the convex polygon
#This minimizes the number of turns taken by the path
def findBestSweepDirection(xPoints, yPoints): 
    #find optimal matrix direction 
    xRot = []
    yRot = []
    tempPoints = []    
    opAngleDist = max(xPoints)-min(xPoints)
    opAngle = 0
    for testAngle in range(1, 360):
        print(opAngle)
        transformAngle = [[np.cos(np.deg2rad(testAngle)), -np.sin(np.deg2rad(testAngle))], [np.sin(np.deg2rad(testAngle)), np.cos(np.deg2rad(testAngle))]]
        tempX = [] 
        for p in range(0, len(xPoints)):
            xyMat = [[xPoints[p]], [yPoints[p]]]
            tempPoints.append(np.matmul(transformAngle, xyMat))
        for p in range(0, len(xPoints)):
            tempX.append(tempPoints[p][0])
        if max(tempX)-min(tempX) < opAngleDist:
            opAngleDist = max(tempX) - min(tempX)
            opAngle = testAngle
        tempPoints = []
    #print(opAngle) 

    #Now rotate the shape by the angle
    finalTransform = [[np.cos(np.deg2rad(opAngle)), -np.sin(np.deg2rad(opAngle))], [np.sin(np.deg2rad(opAngle)), np.cos(np.deg2rad(opAngle))]]
    tempPointsFinal = []
    for i in range(0, len(xPoints)):
         xyMatNew = [[xPoints[i]], [yPoints[i]]]
         tempPointsFinal.append(np.matmul(finalTransform, xyMatNew))
    for p in range(0, len(xPoints)):
            xRot.append(tempPointsFinal[p][0])
            yRot.append(tempPointsFinal[p][1])
    #print(xRot) 
    #print(yRot)
    
    return xRot, yRot
    
def plotGrid(xPoints, yPoints):
    plt.title("Bathydrone Boat Path")
    plt.xlabel("X")
    plt.ylabel("Y")

    plt.grid()
    plt.plot(xPoints, yPoints, marker='o', color='red')
    plt.axis('square')
    plt.show()

def plotPath(xPoints, yPoints, bathyPath):
    plt.title("Bathydrone Boat Path")
    plt.xlabel("X")
    plt.ylabel("Y")

    plt.grid()
    myPlot = plt.plot(xPoints, yPoints, marker='o', color='red')
    plt.plot(bathyPath.pathX, bathyPath.pathY, marker='o', color='green')
    plt.show()

def main():
    #input closed area as points. 
    xPoints = [0.0, 20.0, 50.0, 100.0, 130.0, 40.0, 0.0]
    yPoints = [0.0, -20.0, 0.0, 30.0, 60.0, 80.0, 0.0]
    
    xRot, yRot = findBestSweepDirection(xPoints, yPoints)

    plotGrid(xPoints, yPoints)
    plotGrid(xRot, yRot)
   
    #boatSpecs = HardwareSpecs(1, 1) 
    #bathyPath = Path(xRot, yRot, boatSpecs.rho)
    #plotPath(xRot, yRot, bathyPath)
    return 0


if __name__ == "__main__":
    main()


