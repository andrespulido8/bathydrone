# LAST UPDATE: Nicholas Sardinia, Febuary 12 2023
#!/usr/bin/env python3
import matplotlib.pyplot as plt
import math
import numpy as np


# Updated algorithm, solves any convex polygon based on boat hardware.
# Takes set of points to define polygon. Does not validate convex-ness

# Define the boat hardware
class HardwareSpecs:
    # accounts for radius of curvature and side-scan sonar geometry
    def __init__(self, D, alpha_2):
        self.rho = D*np.tan(alpha_2)
        # rho - radius that constrains the spacing between each
        # D - estimated depth of water
        # alpha_2 = Measured angle related to coverage of side-scan sonar

#Grid point
class GridPoint:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class ConvexArea:
    def __init__(self, numPoints, pointX, pointY):
        self.numPoints = numPoints
        self.pointX = pointX
        self.pointY = pointY


# Generates path, starting from lower-left corner. 
# Lawnmower lines for full convex coveragae.
# Returns path as a series of grid points from bottom left to top right
class Path:
    def __init__(self, pointsX, pointsY, rho):
        self.pointsX = pointsX
        self.pointsY = pointsY
        self.rho = rho
        self.pathX = []
        self.pathY = []
        
        # generate starting point
        self.pathX.append(pointsX[0]+rho)
        self.pathY.append(pointsY[0]+rho)

        # generate path
            # find highest y at current x
            # add point at highest y - rho
            # move right by rho
            # find lowest y at current x
            # move right by rho
            # repeat until currentx = max_x

        done = 0
        currX = self.pointsX[0]+rho
        currY = self.pathY[0]
        
        maxX = 0
        countCurr = 1
        closestLeftSave = 0
        closestRightSave = maxX
        for i in range(len(self.pointsX)):
            if (self.pointsX[i] >= self.pointsX[maxX]):
                maxX = i
        print(self.pointsX[maxX])
        while done != 1:
            print("next")
            if (currX >= self.pointsX[maxX]-rho):
                done = 1
                break
            closestRight = maxX
            closestLeft = 0
            #find the x-points that most nearly bound the current x above the current x position
            for i in range(len(self.pointsX)-1):
                if (self.pointsX[i] >= self.pointsX[closestLeft] and self.pointsX[i]  < currX):
                    closestLeft = i
                if (self.pointsX[i] < self.pointsX[closestRight] and self.pointsX[i]  > currX):
                    closestRight = i
                    #print(self.pointsX[closestRight])
            print(closestLeft)
            print(closestRight)
            #From the tightest bound on X, we may find the next vertical point by interpolation.
            if (closestLeftSave != closestLeft or closestRightSave != closestRight):
                closestLeftSave = closestLeft
                closestRightSave = closestRight
                if (countCurr > 3):
                    countCurr = 1
            if ((self.pointsX[closestRight] - self.pointsX[closestLeft]) != 0):
                slope = (self.pointsY[closestRight]-self.pointsY[closestLeft])/(self.pointsX[closestRight] - self.pointsX[closestLeft])
                print(self.pointsY[closestRight]-self.pointsY[closestLeft])
                print(self.pointsX[closestRight] - self.pointsX[closestLeft])
                print(slope)
            else:
                slope = 0
            vertPos = self.pointsY[closestLeft] + slope*rho*countCurr - 6*rho
            currY = vertPos

            #add point at vertpos
            self.pathX.append(currX)
            self.pathY.append(vertPos)

            #add point to the right of vertpos
            self.pathX.append(currX+rho)
            self.pathY.append(vertPos)

            #TODO allow paths below starting x
            currX = currX + rho
            self.pathX.append(currX)
            self.pathY.append(pointsY[0]+rho)

            currX = currX + rho
            #print(currX)
            self.pathX.append(currX)
            self.pathY.append(pointsY[0]+rho)
            countCurr = countCurr + 2
           

            

            

        
def main():
    #input closed area as points. 
    xArr = [1, 1, 1, 2, 3, 4, 5]
    yArr = [1, 2, 3, 6, 4, 2, 8]
    bathyPlanner =  ConvexArea(len(xArr), xArr, yArr)

    boatSpecs = HardwareSpecs(.25, .25)
    bathyPath = Path(xArr, yArr, boatSpecs.rho) 

    plt.title("Bathydrone Boat Path")
    plt.xlabel("X")
    plt.ylabel("Y")

    plt.grid()
    plt.plot(bathyPlanner.pointX, bathyPlanner.pointY, marker='o', color='red')
    plt.plot(bathyPath.pathX, bathyPath.pathY, marker='o', color='green')
    plt.show()
    #planning = pp(sp1, sp2, dy, is_plot)
    #traj = planning.trajectory(2)
    # planning.plot()
    # print(traj.shape)
    return 0


if __name__ == "__main__":
    main()

#Code from 2022 algorithm (works for squares / rectangles only)
#Doesn't include boat parameters
"""
class pp:
    #Creates inputs for the setpoints ("sp") of a square or rectangle with sp1 
    #as the first initial point as [x,y] input and sp2 as the second point 
    #also as [x,y] input.
    
    # UPDATE: Enter convex polygon as a set of points to 'cvp'
    # enter sp1 as [x,y]
    # enter sp2 as [x,y]
    
    def __init__(self, sp1=[0,0], sp2=[170,80], dy=40, is_plot=False):
        self.sp1 = sp1
        self.sp2 = np.transpose(sp2)
        self.sp = [sp1, sp2]
        self.dy = dy  
        self.deltax = 1
        self.is_plot = is_plot
        self.dr = 6
        #self.numpoints = numpoints
        #self.cvp = []
        

    def path(self, s0=np.array([0, 0])):
        TBased on two initial setpoints, creates the remaining two points 
        based on square/rectangle geometry 
        Inputs:
           s0: initial position x and y of the robot
        
        self.x_distance = self.sp2[0] - self.sp1[0]
        self.y_distance = self.sp2[1] - self.sp1[1]

        self.sp3 = [self.sp1[0] + self.x_distance, self.sp1[1]]
        self.sp4 = [self.sp1[0], self.sp1[1] + self.y_distance]
        self.square = [self.sp1, self.sp2, self.sp3, self.sp4]

        # Sets up variables for the semi-circular cases for the path
        S = []

        h_arr = np.arange(self.sp1[0], self.sp3[0], self.dy)  # circle case
        i_arr = np.arange(
            (self.sp1[0] + (self.dy / 2)), self.sp3[0], self.dy
        )  # circle case

        r=(self.dy-self.sp1[0])/4 #radius of the turn
        k=self.sp4[1]-((1/2)*self.dy) #top semi-circular case
        l=self.sp1[1]+((1/2)*self.dy) #bottom semi-circular case

        T = np.arange(
            self.sp1[0], (self.sp3[0] + self.dy / 2), self.dy / 2
        )  # x-component (straight)
        # TODO: automatically calculate the number of points or have it as an input
        S = np.arange((self.sp1[1] + (self.dy / 2)), (k), 8)  # y-component (straight)

        # TODO: do not have an overlap of green with red and green with blue points
        # TODO: get rid of all the lists by preallocating memory of the np arrays
        xi = []
        yi = []
        xT = []
        yT = []
        xh = []
        yh = []
        X_list = []
        Y_list = []
        ii = 0

        for count, x in enumerate(T):
            count = int(count)
            if count % 2 == 0:
                for y in S:
                    xT.append(x)
                    yT.append(y)
                    plt.scatter(x, y, c="g") if self.is_plot else None
                xT_arr = np.array(xT)
                yT_arr = np.array(yT)
                xT = []
                yT = []

                x0 = h_arr[ii] - r
                x1 = h_arr[ii] + r
                xhh = np.linspace(x0, x1, self.dr)
                yhh = k + np.sqrt(r**2 - (xhh - h_arr[ii]) ** 2)
                xh.append(xhh + (self.dy / 4))
                yh.append(yhh)
                plt.scatter(xhh + (self.dy / 4), yhh, c="b") if self.is_plot else None
                xh_arr = np.concatenate(xh)
                yh_arr = np.concatenate(yh)
                xh = []
                yh = []

                Xtop = np.concatenate((xT_arr, xh_arr))
                Ytop = np.concatenate((yT_arr, yh_arr))
            else:
                for y in np.flip(S):
                    xT.append(x)
                    yT.append(y)
                    plt.scatter(x, y, c="g") if self.is_plot else None
                xT_arr = np.array(xT)
                yT_arr = np.array(yT)
                xT = []
                yT = []

                if ii < len(i_arr) - 1:
                    x0 = i_arr[ii] - r
                    x1 = i_arr[ii] + r
                    # TODO: evenly spaced angles instead of dx (self.dr)
                    xii = np.linspace(x0, x1, self.dr)
                    yii = l - np.sqrt(r**2 - (xii - i_arr[ii]) ** 2)
                    xi.append(xii + (self.dy / 4))
                    yi.append(yii)
                    plt.scatter(
                        xii + (self.dy / 4), yii, c="red"
                    ) if self.is_plot else None
                    xi_arr = np.concatenate(xi)
                    yi_arr = np.concatenate(yi)
                    xi = []
                    yi = []

                    Xbottom = np.concatenate((xT_arr, xi_arr))
                    Ybottom = np.concatenate((yT_arr, yi_arr))
                else:
                    Xbottom = xT_arr
                    Ybottom = yT_arr

                X = np.concatenate((Xtop, Xbottom))
                Y = np.concatenate((Ytop, Ybottom))
                X_list.append(X)
                Y_list.append(Y)
                ii += 1
                if ii == len(i_arr):
                    break

        self.X = np.concatenate(X_list)
        self.Y = np.concatenate(Y_list)
        self.X = self.X.reshape(self.X.size)
        self.Y = self.Y.reshape(self.Y.size)
        plt.axis("equal") if self.is_plot else None

        plt.show() if self.is_plot else None
        # TODO: set axis name with dimensions

        return [self.X + s0[0], self.Y + s0[1]]

    def heading(self):
        Computes the heading of the path at each index
        based on the difference between the next and previous
        points
        
        X, Y = (self.X, self.Y)
        h = np.zeros(len(X))
        for i in range(1, len(X) - 1):
            h[i] = np.arctan2(Y[i + 1] - Y[i - 1], X[i + 1] - X[i - 1])
        h[0] = h[1]
        h[-1] = h[-2]
        return h

    def velocity(self):
        Computes the velocity by getting the
        difference in each axis between the next
        and previous points
        
        X, Y = (self.X, self.Y)
        d = np.zeros((len(X), 2))
        for i in range(1, len(X) - 1):
            d[i] = np.array([X[i + 1] - X[i - 1], Y[i + 1] - Y[i - 1]])
        d[0] = d[1]
        d[-1] = d[-2]
        # normalize the difference
        d[:, 0] = d[:, 0] * self.max_vel / np.linalg.norm(d, axis=1)
        d[:, 1] = d[:, 1] * self.max_vel / np.linalg.norm(d, axis=1)
        return d

    def trajectory(self, max_vel=1):
        Returns the trajectory as a nd array of
        position, heading and velocity
        self.max_vel = max_vel
        X, Y = self.path()
        h = self.heading()
        d = self.velocity()
        return np.array([X, Y, h, d[:, 0], d[:, 1], np.repeat(0, len(X))]).T

    def plot(self):
        Plots the path
        X, Y = self.path()
        plt.scatter(self.X, self.Y, c="r")
        # Plot rectangle boundary knowing sp1 and sp2
        plt.plot(
            [self.sp1[0], self.sp2[0], self.sp2[0], self.sp1[0], self.sp1[0]],
            [self.sp1[1], self.sp1[1], self.sp2[1], self.sp2[1], self.sp1[1]],
            "--k",
        )
        # TODO: title: " trajectory of the robot"
        plt.axis("equal")
        plt.show()

"""



