import numpy as np

# generated_path = [
#                      [397.96,      198.88],
#                      [397.96,      534.12],
#                      [435.27,      534.12],
#                      [435.27,      198.88],
#                      [472.58,      198.88],
#                      [472.58,      534.12],
#                      [509.88,      534.12],
#                      [509.88,      198.88],
#                      [547.19,      198.88],
#                      [547.19,      534.12],
#                      [584.5,       534.12],
#                      [584.5,       198.88],
#                      [621.81,      198.88],
#                      [621.81,      534.12],
#                      [659.12,      534.12],
#                      [659.12,      198.88],
#                      [696.42,      198.88],
#                      [696.42,      534.12],
#                      [733.73,      534.12],
#                      [733.73,      273.38],
#                      [771.04,      273.38],
#                      [771.04,      534.12]
#                 ]
# generated_path = np.array(generated_path)


def accel_del_waypoints(generated_path):
    """Function created to append additional waypoints to existing way points generated by the generated_path function.
    An "acceleration" waypoint is added into the waypoint sequence as the 2nd, 6th, 10th, etc iteration while the "deceleration" waypoint
    is added into the waypoint sequence as the 3rd, 7th, 11th, etc iteration. The accleration waypoint serves as an indication for the drone to 
    change its velocity to a variable speed while the deceleration waypoint serves as an indication for the drone to decrease its velocity to a 
    variable speed right before changing directions to pass the spline waypoint.
    
    Args:
        generated_path: numpy array of waypoints that are located at the edge of each transect indicating a change of direction.
        
    Returns:
        generated_path: updated generated path with acceleration and deceleration waypoints appended to original waypoint list."""
    
    generated_path = np.array(generated_path)
    acceleration_transect_distance = 0.25
    deceleration_transect_distance = 0.75

    new_waypoints = []

    for i in range(1, len(generated_path), 2):  # interpolation to gather acceleration and deceleration waypoints along transect
        direction_vector = generated_path[i] - generated_path[i-1]

        acceleration_waypoint = generated_path[i-1] + acceleration_transect_distance * direction_vector
        new_waypoints.append(acceleration_waypoint)

        deceleration_waypoint = generated_path[i-1] + deceleration_transect_distance * direction_vector
        new_waypoints.append(deceleration_waypoint)

    new_waypoints = np.array(new_waypoints)

    # concatenating new waypoints to original path planned waypoints
    acceleration_indices_to_modify = list(range(1, generated_path.shape[0]*2, 3))
    deceleration_indices_to_modify = list(range(2, generated_path.shape[0]*2, 4))

    for idx, waypoint in zip(acceleration_indices_to_modify, new_waypoints[::2]):
        generated_path = np.insert(generated_path, idx, waypoint, axis=0)

    for idx, waypoint in zip(deceleration_indices_to_modify, new_waypoints[1::2]):
        generated_path = np.insert(generated_path, idx, waypoint, axis=0)

    return generated_path


























    # transect_length = 335.24  # in pixels
    # accel_way_point_distance = transect_length * 0.25  # variable to change
    # decel_way_point_distance = transect_length * 0.75  # variable to change

    # new_waypoints = []
    # for i in range(transects):
    #     coordinate_index = 2 * i
    #     if coordinate_index < len(generated_path):
    #         # Access the original coordinate
    #         original_coordinate = generated_path[coordinate_index]
    #
    #         if i % 2 == 0:
    #             accel_way_point_y = original_coordinate[1] + accel_way_point_distance
    #             new_waypoints.append([original_coordinate[0], accel_way_point_y])
    #
    #             decel_way_point_y = original_coordinate[1] + decel_way_point_distance
    #             new_waypoints.append([original_coordinate[0], decel_way_point_y])
    #         else:
    #             accel_way_point_y = original_coordinate[1] - accel_way_point_distance
    #             new_waypoints.append([original_coordinate[0], accel_way_point_y])
    #
    #             decel_way_point_y = original_coordinate[1] - decel_way_point_distance
    #             new_waypoints.append([original_coordinate[0], decel_way_point_y])
    #
    # #  appending new waypoint list to generated path list
    # generated_path = generated_path.tolist()
    #
    # generated_path[1:1] = new_waypoints[0:2]
    # generated_path[5:5] = new_waypoints[2:4]
    # generated_path[9:9] = new_waypoints[4:6]
    # generated_path[13:13] = new_waypoints[6:8]
    # generated_path[17:17] = new_waypoints[8:10]
    # generated_path[21:21] = new_waypoints[10:12]
    # generated_path[25:25] = new_waypoints[12:14]
    # generated_path[29:29] = new_waypoints[14:16]
    # generated_path[33:33] = new_waypoints[16:18]
    # generated_path[37:37] = new_waypoints[18:20]
    # generated_path[41:41] = new_waypoints[20:22]
    # generated_path = np.array(generated_path)

    # return generated_path


# accel_del_waypoints(generated_path)
